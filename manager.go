package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"text/template"
	"time"
)

type HookManager struct {
	config     *Config
	verbose    bool
	configPath string
	gitDir     string
}

func NewHookManager(configPath string, verbose bool) *HookManager {
	return &HookManager{
		configPath: configPath,
		verbose:    verbose,
	}
}

func (hm *HookManager) init() error {
	if hm.config != nil {
		return nil
	}

	// Load configuration
	config, err := LoadConfig(hm.configPath)
	if err != nil {
		return fmt.Errorf("failed to load configuration: %w", err)
	}
	hm.config = config

	// Override verbose setting if specified via flag
	if hm.verbose {
		hm.config.Settings.Verbose = true
	}

	// Find git directory
	gitDir, err := hm.findGitDirectory()
	if err != nil {
		return fmt.Errorf("not in a git repository: %w", err)
	}
	hm.gitDir = gitDir

	return nil
}

func (hm *HookManager) findGitDirectory() (string, error) {
	cmd := exec.Command("git", "rev-parse", "--git-dir")
	output, err := cmd.Output()
	if err != nil {
		return "", err
	}
	
	gitDir := strings.TrimSpace(string(output))
	if !filepath.IsAbs(gitDir) {
		wd, err := os.Getwd()
		if err != nil {
			return "", err
		}
		gitDir = filepath.Join(wd, gitDir)
	}
	
	return gitDir, nil
}

func (hm *HookManager) validateScripts() error {
	var missingItems []string
	
	for hookName, scripts := range hm.config.Hooks {
		for _, script := range scripts {
			if script.Script != "" {
				// Validate script file exists
				// If it has arguments, only check the first part (the actual file)
				scriptPath := script.Script
				if strings.Contains(scriptPath, " ") {
					scriptPath = strings.Fields(scriptPath)[0]
				}
				
				if _, err := os.Stat(scriptPath); os.IsNotExist(err) {
					missingItems = append(missingItems, fmt.Sprintf("script file '%s' not found (from: %s, hook: %s)", scriptPath, script.Script, hookName))
				}
			} else if script.Command != "" {
				// Validate command exists in PATH
				cmd := strings.Fields(script.Command)[0]
				if _, err := exec.LookPath(cmd); err != nil {
					missingItems = append(missingItems, fmt.Sprintf("command '%s' not found in PATH (from: %s, hook: %s)", cmd, script.Command, hookName))
				}
			}
		}
	}
	
	if len(missingItems) > 0 {
		return fmt.Errorf("missing scripts/commands:\n  %s", strings.Join(missingItems, "\n  "))
	}
	
	return nil
}

func (hm *HookManager) InstallHooks() error {
	if err := hm.init(); err != nil {
		return err
	}

	// Validate that all referenced scripts exist before installing
	if err := hm.validateScripts(); err != nil {
		return err
	}

	hooksDir := filepath.Join(hm.gitDir, "hooks")
	
	// Create hooks directory if it doesn't exist
	if err := os.MkdirAll(hooksDir, 0755); err != nil {
		return fmt.Errorf("failed to create hooks directory: %w", err)
	}

	// Create backup directory if needed
	if hm.config.Settings.BackupExisting {
		backupDir := filepath.Join(hm.gitDir, hm.config.Settings.BackupDirectory)
		if err := os.MkdirAll(backupDir, 0755); err != nil {
			return fmt.Errorf("failed to create backup directory: %w", err)
		}
	}

	for hookName, scripts := range hm.config.Hooks {
		if len(scripts) == 0 {
			continue
		}

		if hm.config.Settings.Verbose {
			fmt.Printf("Installing hook: %s\n", hookName)
		}

		if err := hm.installHook(hookName, scripts, hooksDir); err != nil {
			return fmt.Errorf("failed to install hook %s: %w", hookName, err)
		}
	}

	return nil
}

func (hm *HookManager) installHook(hookName string, scripts []HookScript, hooksDir string) error {
	hookPath := filepath.Join(hooksDir, hookName)
	
	// Backup existing hook if it exists and backup is enabled
	if hm.config.Settings.BackupExisting {
		if _, err := os.Stat(hookPath); err == nil {
			backupDir := filepath.Join(hm.gitDir, hm.config.Settings.BackupDirectory)
			backupPath := filepath.Join(backupDir, fmt.Sprintf("%s.%d", hookName, time.Now().Unix()))
			
			if err := os.Rename(hookPath, backupPath); err != nil {
				return fmt.Errorf("failed to backup existing hook: %w", err)
			}
			
			if hm.config.Settings.Verbose {
				fmt.Printf("  Backed up existing hook to: %s\n", backupPath)
			}
		}
	}

	// Generate hook script content
	content, err := hm.generateHookScript(hookName, scripts)
	if err != nil {
		return fmt.Errorf("failed to generate hook script: %w", err)
	}

	// Write hook file
	if err := os.WriteFile(hookPath, []byte(content), 0755); err != nil {
		return fmt.Errorf("failed to write hook file: %w", err)
	}

	if hm.config.Settings.Verbose {
		fmt.Printf("  Hook installed: %s (%d scripts)\n", hookName, len(scripts))
	}

	return nil
}

func (hm *HookManager) generateHookScript(hookName string, scripts []HookScript) (string, error) {
	tmpl := `#!/bin/sh
# Generated by hooky - Do not edit manually
# Hook: {{.HookName}}
# Generated at: {{.Timestamp}}

set -e

{{range .Scripts}}
# {{.Description}}
echo "Running: {{.Name}}"
cd "{{$.WorkingDir}}"
{{if .Script}}{{.Script}} "$@"{{else}}{{.Command}} "$@"{{end}}
if [ $? -ne 0 ]; then
    echo "Hook failed: {{.Name}}"
    exit 1
fi
{{end}}
`

	workingDir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	data := struct {
		HookName   string
		Timestamp  string
		Scripts    []HookScript
		WorkingDir string
	}{
		HookName:   hookName,
		Timestamp:  time.Now().Format(time.RFC3339),
		Scripts:    scripts,
		WorkingDir: workingDir,
	}

	t, err := template.New("hook").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var content strings.Builder
	if err := t.Execute(&content, data); err != nil {
		return "", err
	}

	// Adjust shebang for Windows
	script := content.String()
	if runtime.GOOS == "windows" {
		script = strings.Replace(script, "#!/bin/sh", "#!/bin/bash", 1)
	}

	return script, nil
}

func (hm *HookManager) UninstallHooks() error {
	if err := hm.init(); err != nil {
		return err
	}

	hooksDir := filepath.Join(hm.gitDir, "hooks")

	for hookName := range hm.config.Hooks {
		hookPath := filepath.Join(hooksDir, hookName)
		
		if _, err := os.Stat(hookPath); os.IsNotExist(err) {
			if hm.config.Settings.Verbose {
				fmt.Printf("Hook not found: %s\n", hookName)
			}
			continue
		}

		// Check if this is a hooky-generated hook
		content, err := os.ReadFile(hookPath)
		if err != nil {
			return fmt.Errorf("failed to read hook %s: %w", hookName, err)
		}

		if !strings.Contains(string(content), "Generated by hooky") {
			if hm.config.Settings.Verbose {
				fmt.Printf("Skipping non-hooky hook: %s\n", hookName)
			}
			continue
		}

		if err := os.Remove(hookPath); err != nil {
			return fmt.Errorf("failed to remove hook %s: %w", hookName, err)
		}

		if hm.config.Settings.Verbose {
			fmt.Printf("Removed hook: %s\n", hookName)
		}
	}

	return nil
}

func (hm *HookManager) ListHooks() error {
	if err := hm.init(); err != nil {
		return err
	}

	fmt.Printf("Configuration: %s\n\n", hm.configPath)

	if len(hm.config.Hooks) == 0 {
		fmt.Println("No hooks configured")
		return nil
	}

	var missingScripts []string

	for hookName, scripts := range hm.config.Hooks {
		fmt.Printf("Hook: %s\n", hookName)
		
		if len(scripts) == 0 {
			fmt.Printf("  No scripts configured\n")
		} else {
			for i, script := range scripts {
				status := "✅"
				var scriptType, scriptValue string
				
				if script.Script != "" {
					scriptType = "script"
					scriptValue = script.Script
					// For script files, check if file exists
					// If it has arguments, only check the first part (the actual file)
					scriptPath := script.Script
					if strings.Contains(scriptPath, " ") {
						scriptPath = strings.Fields(scriptPath)[0]
					}
					
					if _, err := os.Stat(scriptPath); os.IsNotExist(err) {
						status = "❌ MISSING"
						missingScripts = append(missingScripts, fmt.Sprintf("script file '%s' not found (from: %s, hook: %s)", scriptPath, script.Script, hookName))
					}
				} else if script.Command != "" {
					scriptType = "command"
					scriptValue = script.Command
					// For commands, check if command exists in PATH
					cmd := strings.Fields(script.Command)[0]
					if _, err := exec.LookPath(cmd); err != nil {
						status = "❌ MISSING"
						missingScripts = append(missingScripts, fmt.Sprintf("command '%s' not found in PATH (from: %s, hook: %s)", cmd, script.Command, hookName))
					}
				}
				
				fmt.Printf("  %d. %s (%s) [%s] %s\n", i+1, script.Name, scriptValue, scriptType, status)
				if script.Description != "" {
					fmt.Printf("     %s\n", script.Description)
				}
			}
		}
		fmt.Println()
	}

	if len(missingScripts) > 0 {
		fmt.Printf("⚠️  Missing scripts that would prevent installation:\n")
		for _, missing := range missingScripts {
			fmt.Printf("  %s\n", missing)
		}
		fmt.Println()
	}

	return nil
}