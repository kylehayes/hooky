package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

func TestFullWorkflow(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	tmpDir := t.TempDir()
	
	// Create test scripts
	testScript := filepath.Join(tmpDir, "test-script.sh")
	err := os.WriteFile(testScript, []byte(`#!/bin/bash
echo "Running test script with args: $@"
exit 0
`), 0755)
	if err != nil {
		t.Fatalf("Failed to create test script: %v", err)
	}

	// Create config file
	testScriptName := "./" + filepath.Base(testScript)
	configContent := fmt.Sprintf(`
hooks:
  pre-commit:
    - name: "test-script"
      script: "%s"
      description: "Test script execution"
    - name: "echo-command"
      command: "echo 'Running echo command'"
      description: "Test command execution"
  
  pre-push:
    - name: "validation"
      command: "echo 'Pre-push validation'"
      description: "Pre-push validation"

settings:
  verbose: true
  backup_existing: true
`, testScriptName)
	
	configPath := filepath.Join(tmpDir, "hooky.yaml")
	err = os.WriteFile(configPath, []byte(configContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write config: %v", err)
	}

	// Create git repository
	gitDir := filepath.Join(tmpDir, ".git")
	hooksDir := filepath.Join(gitDir, "hooks")
	err = os.MkdirAll(hooksDir, 0755)
	if err != nil {
		t.Fatalf("Failed to create git hooks dir: %v", err)
	}
	
	// Initialize git repo
	initCmd := exec.Command("git", "init")
	initCmd.Dir = tmpDir
	err = initCmd.Run()
	if err != nil {
		t.Fatalf("Failed to init git repo: %v", err)
	}

	// Change to temp directory
	oldDir, _ := os.Getwd()
	defer os.Chdir(oldDir)
	os.Chdir(tmpDir)

	// Build hooky binary
	hookyPath := filepath.Join(tmpDir, "hooky")
	buildCmd := exec.Command("go", "build", "-o", hookyPath)
	buildCmd.Dir = oldDir
	err = buildCmd.Run()
	if err != nil {
		t.Fatalf("Failed to build hooky: %v", err)
	}

	// Test --list command
	t.Run("list hooks", func(t *testing.T) {
		cmd := exec.Command(hookyPath, "--list")
		output, err := cmd.CombinedOutput()
		if err != nil {
			t.Fatalf("List command failed: %v\nOutput: %s", err, output)
		}

		outputStr := string(output)
		if !strings.Contains(outputStr, "test-script") {
			t.Error("Output should contain test-script")
		}
		if !strings.Contains(outputStr, "[script]") {
			t.Error("Output should show [script] type")
		}
		if !strings.Contains(outputStr, "[command]") {
			t.Error("Output should show [command] type")
		}
		if !strings.Contains(outputStr, "✅") {
			t.Error("Output should show validation success")
		}
	})

	// Test --install command
	t.Run("install hooks", func(t *testing.T) {
		cmd := exec.Command(hookyPath, "--install")
		output, err := cmd.CombinedOutput()
		if err != nil {
			t.Fatalf("Install command failed: %v\nOutput: %s", err, output)
		}

		// Check that hook files were created
		preCommitPath := filepath.Join(hooksDir, "pre-commit")
		if _, err := os.Stat(preCommitPath); os.IsNotExist(err) {
			t.Error("pre-commit hook file was not created")
		}

		prePushPath := filepath.Join(hooksDir, "pre-push")
		if _, err := os.Stat(prePushPath); os.IsNotExist(err) {
			t.Error("pre-push hook file was not created")
		}

		// Check hook content
		content, err := os.ReadFile(preCommitPath)
		if err != nil {
			t.Fatalf("Failed to read pre-commit hook: %v", err)
		}

		hookContent := string(content)
		if !strings.Contains(hookContent, "test-script.sh") {
			t.Error("Hook should contain script path")
		}
		if !strings.Contains(hookContent, "echo 'Running echo command'") {
			t.Error("Hook should contain command")
		}
		if !strings.Contains(hookContent, "Generated by hooky") {
			t.Error("Hook should contain hooky signature")
		}
	})

	// Test hook execution
	t.Run("execute hooks", func(t *testing.T) {
		preCommitPath := filepath.Join(hooksDir, "pre-commit")
		
		// Check hook content first for debugging
		content, err := os.ReadFile(preCommitPath)
		if err != nil {
			t.Fatalf("Failed to read hook content: %v", err)
		}
		t.Logf("Hook content:\n%s", string(content))
		
		// Execute the hook directly
		cmd := exec.Command("bash", preCommitPath, "test-arg")
		cmd.Dir = tmpDir
		output, err := cmd.CombinedOutput()
		if err != nil {
			t.Fatalf("Hook execution failed: %v\nOutput: %s", err, output)
		}

		outputStr := string(output)
		if !strings.Contains(outputStr, "Running: test-script") {
			t.Error("Hook output should show running test-script")
		}
		if !strings.Contains(outputStr, "Running: echo-command") {
			t.Error("Hook output should show running echo-command")
		}
		if !strings.Contains(outputStr, "Running echo command") {
			t.Error("Hook output should contain command output")
		}
	})

	// Test --uninstall command
	t.Run("uninstall hooks", func(t *testing.T) {
		cmd := exec.Command(hookyPath, "--uninstall")
		output, err := cmd.CombinedOutput()
		if err != nil {
			t.Fatalf("Uninstall command failed: %v\nOutput: %s", err, output)
		}

		// Check that hook files were removed
		preCommitPath := filepath.Join(hooksDir, "pre-commit")
		if _, err := os.Stat(preCommitPath); !os.IsNotExist(err) {
			t.Error("pre-commit hook file should have been removed")
		}

		prePushPath := filepath.Join(hooksDir, "pre-push")
		if _, err := os.Stat(prePushPath); !os.IsNotExist(err) {
			t.Error("pre-push hook file should have been removed")
		}
	})
}

func TestErrorHandling(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	tmpDir := t.TempDir()

	// Create invalid config
	configContent := `
hooks:
  pre-commit:
    - name: "invalid"
      script: "missing-script.sh"
      description: "Missing script"
    - name: "invalid-command"
      command: "nonexistent-command-12345"
      description: "Missing command"
`
	
	configPath := filepath.Join(tmpDir, "hooky.yaml")
	err := os.WriteFile(configPath, []byte(configContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write config: %v", err)
	}

	// Create git repository
	gitDir := filepath.Join(tmpDir, ".git")
	err = os.MkdirAll(gitDir, 0755)
	if err != nil {
		t.Fatalf("Failed to create git dir: %v", err)
	}
	
	// Initialize git repo
	initCmd := exec.Command("git", "init")
	initCmd.Dir = tmpDir
	err = initCmd.Run()
	if err != nil {
		t.Fatalf("Failed to init git repo: %v", err)
	}

	// Change to temp directory
	oldDir, _ := os.Getwd()
	defer os.Chdir(oldDir)
	os.Chdir(tmpDir)

	// Build hooky binary
	hookyPath := filepath.Join(tmpDir, "hooky")
	buildCmd := exec.Command("go", "build", "-o", hookyPath)
	buildCmd.Dir = oldDir
	err = buildCmd.Run()
	if err != nil {
		t.Fatalf("Failed to build hooky: %v", err)
	}

	// Test that install fails with missing scripts/commands
	t.Run("install with missing dependencies", func(t *testing.T) {
		cmd := exec.Command(hookyPath, "--install")
		output, err := cmd.CombinedOutput()
		if err == nil {
			t.Error("Install should have failed with missing dependencies")
		}

		outputStr := string(output)
		if !strings.Contains(outputStr, "missing-script.sh") {
			t.Error("Error should mention missing script")
		}
		if !strings.Contains(outputStr, "nonexistent-command-12345") {
			t.Error("Error should mention missing command")
		}
	})

	// Test list shows validation errors
	t.Run("list shows validation errors", func(t *testing.T) {
		cmd := exec.Command(hookyPath, "--list")
		output, err := cmd.CombinedOutput()
		if err != nil {
			t.Fatalf("List command failed: %v", err)
		}

		outputStr := string(output)
		if !strings.Contains(outputStr, "❌ MISSING") {
			t.Error("List should show missing items")
		}
		if !strings.Contains(outputStr, "⚠️") {
			t.Error("List should show warning about missing items")
		}
	})
}

func TestConfigValidation(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	tmpDir := t.TempDir()

	tests := []struct {
		name           string
		configContent  string
		expectError    bool
		expectedErrMsg string
	}{
		{
			name: "both script and command",
			configContent: `
hooks:
  pre-commit:
    - name: "invalid"
      script: "test.sh"
      command: "echo test"
      description: "Invalid config"
`,
			expectError:    true,
			expectedErrMsg: "cannot specify both 'script' and 'command'",
		},
		{
			name: "neither script nor command",
			configContent: `
hooks:
  pre-commit:
    - name: "invalid"
      description: "Invalid config"
`,
			expectError:    true,
			expectedErrMsg: "must specify either 'script' or 'command'",
		},
		{
			name: "invalid YAML syntax",
			configContent: `
hooks:
  pre-commit:
    - name: "test"
      script: "unclosed quote
`,
			expectError:    true,
			expectedErrMsg: "failed to parse config file",
		},
	}

	// Change to temp directory
	oldDir, _ := os.Getwd()
	defer os.Chdir(oldDir)
	os.Chdir(tmpDir)

	// Build hooky binary
	hookyPath := filepath.Join(tmpDir, "hooky")
	buildCmd := exec.Command("go", "build", "-o", hookyPath)
	buildCmd.Dir = oldDir
	err := buildCmd.Run()
	if err != nil {
		t.Fatalf("Failed to build hooky: %v", err)
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			configPath := filepath.Join(tmpDir, "test-config.yaml")
			err := os.WriteFile(configPath, []byte(tt.configContent), 0644)
			if err != nil {
				t.Fatalf("Failed to write config: %v", err)
			}

			cmd := exec.Command(hookyPath, "--config", configPath, "--list")
			output, err := cmd.CombinedOutput()

			if tt.expectError {
				if err == nil {
					t.Errorf("Expected error but command succeeded. Output: %s", output)
					return
				}
				
				outputStr := string(output)
				if !strings.Contains(outputStr, tt.expectedErrMsg) {
					t.Errorf("Expected error message to contain '%s', got: %s", tt.expectedErrMsg, outputStr)
				}
				return
			}

			if err != nil {
				t.Errorf("Unexpected error: %v\nOutput: %s", err, output)
			}
		})
	}
}